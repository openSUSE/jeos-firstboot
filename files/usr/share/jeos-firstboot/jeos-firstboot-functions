stty_size() {
	set -- `stty size`; LINES=$1; COLUMNS=$2
	# stty size can return zero when not ready or
	# its a serial console
	if [ "$COLUMNS" = "0" -o "$LINES" = "0" ]; then
		LINES=24
		COLUMNS=80
	fi

	let dh_menu=LINES-15
	let dh_text=LINES-5
}
stty_size

result=
list=
password=''
modules=()

if pushd "/usr/share/jeos-firstboot/modules" &>/dev/null; then
        for module in *; do
                if [ -f "${module}" ] && source "${module}"; then
                        modules+=("${module}")
                fi
        done
        popd &>/dev/null
fi

call_module() {
	local module="$1"
	local module_func="$2"
	module_function="${module}_${module_func}"
	[ "$(type -t -- "${module_function}")" = "function" ] || return 1
	"${module_function}" && true # To not trigger errexit
	ret=$?
	[ $ret -eq 0 ] || return $ret
}

call_module_hook() {
        local hook="$1"
        for module in "${modules[@]}"; do
		call_module ${module} ${hook} || continue
        done
        return 0
}

d(){
	while true
	do
		retval=0
		# Bash makes it a bit annoying to read the output of a different FD into a variable, it
		# only supports reading stdout by itself. So redirect 3 to stdout and 1 to the real stdout.
		exec {stdoutfd}>&1
		result="$(dialog --backtitle "$PRETTY_NAME" --output-fd 3 "$@" 3>&1 1>&${stdoutfd})" || retval=$?
		# Word splitting makes it necessary to use eval here.
		eval "exec ${stdoutfd}>&-"
		case $retval in
		  0)
			return 0
			;;
		  1|255)
			dialog --backtitle "$PRETTY_NAME" --yesno $"Do you really want to quit?" 0 0 && exit 1
			continue
			;;
		esac
	done
}

warn(){
	d --title $"Warning" --msgbox "$1" 6 40
}

# Given the number of total item pairs, outputs the number of items to display at once
menuheight() {
	local height=$(($1 / 2))
	[ "$height" -le "$dh_menu" ] || height="$dh_menu"
	echo $height
}

# localectl --no-pager list-keymaps does not list aliases (symlinks), but those are used
# by YaST/langset.sh, so we need to show them.
findkeymaps()
{
        list=()
        local line
        while read line; do
                list+=("${line%.map.gz}" '')
        done < <(find /usr/share/kbd/keymaps -name '*.map.gz' -printf "%f\n" | sort -u)
        [ -n "$list" ]
}

findlocales()
{
        list=()
        local l locale
        # List only locales which are both in live-langset-data and glibc-locale(-base)
        for l in /usr/share/langset/*; do
                locale="${l#/usr/share/langset/}"
                [ -d "/usr/lib/locale/${locale}.utf8" ] || continue
                list+=("${locale}" '')
        done
        [ -n "$list" ]
}

get_current_locale()
{
	cur_locale=`awk -F= '$1 == "LANG" { print $2; exit }' /etc/locale.conf`
	[ -z "$cur_locale" ] && cur_locale="en_US"
	echo ${cur_locale}
}

apply_locale()
{
	if [ ! -z "$JEOS_LOCALE" ]; then
		run langset.sh $JEOS_LOCALE || warn $"Setting the locale failed"
	fi
}

apply_locale_and_keytable()
{
	if [ ! -z "$JEOS_LOCALE" -a ! -z "$JEOS_KEYTABLE" ]; then
		# Activate the selected keyboard layout
		run langset.sh "$JEOS_LOCALE" "$JEOS_KEYTABLE" || warn $"Setting the keyboard layout failed"
	fi
}

apply_password()
{
	# FIXME: systemd-firstboot doesn't set password if shadow present
	if [ -n "$password" ]; then
		run echo "root:$password" | run /usr/sbin/chpasswd
	fi
}

# Resolves /dev/console and /dev/tty0
resolve_tty() {
        local tty="$1"
        if [ "$tty" = "/dev/console" ]; then
                tty=$(awk '{printf "/dev/%s", $NF}' /sys/class/tty/console/active)
        fi

        if [ "$tty" = "/dev/tty0" ]; then
                printf "/dev/%s" "$(cat /sys/class/tty/tty0/active)"
        else
                echo -n "$tty"
        fi
}

# vim: syntax=sh
